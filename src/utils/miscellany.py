import os
import yaml
import torch
import pprint
import logging
import argparse
import numpy as np
import pandas as pd
from typing import Tuple
from torch.cuda.amp import autocast
from SimpleITK import GetImageFromArray, WriteImage
from ..utils.metrics import METRICS
from ..utils.metrics import calculate_metrics



def save_args(args: argparse.Namespace):
    """
    This function saves parsed arguments into config file.


    Parameters
    ----------
    args (dict{arg:value}): Arguments for this run

    """

    config = vars(args).copy()
    del config['save_folder'], config['seg_folder']

    logging.info(f"Execution for configuration:")
    pprint.pprint(config)

    config_file = args.save_folder / "config_file.yaml"
    with config_file.open("w") as file:
        yaml.dump(config, file)


def model_prediction(model: torch.nn.Module, sequences: torch.tensor) -> np.ndarray:
    """
    This function takes as input the sequences of a MRI and a model to generate an automatic segmentation.

    Params:
    *******
        - model: Trained model
        - sequences: Sequences to consider

    Return:
    *******
        segmentation: Automatic segmentation generated by the model
    """
    sequences = sequences.cuda()
    with autocast():
        with torch.no_grad():
            segmentation = torch.sigmoid(model(sequences))
            segmentation = segmentation[0].cpu().numpy() > 0.5

    return segmentation


def regions_to_labels(segmentation: np.ndarray, regions: Tuple[str]) -> np.ndarray:
    """
    This function takes a input a segmentation as a 3D np.array and generates

    Params:
    *******
        - segmentation: segmentation predicted by the model
        - regions: regions to assess

    Return:
    *******
        - et: enhancing tumor label
        - net: necrotic and non-enhancing tumor core label
        - ed: peritumoral edema label

    """

    if len(regions) == 3:
        et = segmentation[0]
        net = np.logical_and(segmentation[1], np.logical_not(et))
        ed = np.logical_and(segmentation[2], np.logical_not(segmentation[1]))
    elif len(regions) == 1:
        if "et" in regions:
            et = segmentation[0]
        elif "tc" in regions:
            net = segmentation[0]
        elif "wt" in regions:
            ed = segmentation[0]
    else:
        assert "ERROR: The number of regions should be 1 or 3"

    label_map = np.zeros(segmentation[0].shape)
    if "et" in vars():
        label_map[et] = 4
    elif "net" in vars():
        label_map[net] = 1
    elif "ed" in vars():
        label_map[ed] = 2

    return label_map


def generate_boxplot_metrics(metrics_df: pd.DataFrame, path: str):
    """
    This function generates a boxplot for each metric measured.

    Params:
    *******
        - metrics_df: Dataframe which contains the information
        - path: Path where the images are stored

    Return:
    *******
        - It does not return anything, but it store a set of boxplot in the path specified.

    """
    os.mkdir(path)
    for metric in METRICS:
        metrics_df.boxplot(metric, by="region").get_figure().savefig(f"{path}{metric}.png")


def generate_segmentations(
        data_loader: torch.utils.data.dataloader.DataLoader,
        model: torch.nn.Module,
        args: argparse.Namespace
):
    """
    This function takes a model and torch DataLoader to generate a segmentation. It also store the sequences and
    ground truth cropped, and the segmentation predicted.

    Params:
    *******
        - data_loader (DataLoader): torch DataLoader which contains information of the patient (id, sequences, gt, ..)
        - model (torch.nn.Module): model used to compute the segmentation
        - writer (SummaryWriter): tensorboard object in which we write some results
        - args (dict{arg:value}): arguments for this run

    Return:
    *******
    It does not return anything. However, it generates several images contained into args.save_folder/metrics and some
    .csv files which store a summary of metrics got by segmentations predicted and results got for each patient.
    """

    metrics_list = []
    for i, batch in enumerate(data_loader):

        # Getting image attributes
        sequences = batch["sequences"]
        ground_truth = batch["ground_truth"][0].cpu().numpy()
        patient_id = batch["patient_id"][0]
        logging.info(f"Processing patient {patient_id} ...")

        # Predicting segmentation
        segmentation = model_prediction(model=model, sequences=sequences)
        logging.info(f"Segmentation calculated...")

        # Evaluating ground truth and segmentation
        patient_metric_list = calculate_metrics(ground_truth=ground_truth, segmentation=segmentation,
                                                patient=patient_id, regions=args.regions)
        metrics_list.append(patient_metric_list)
        logging.info(f"Metrics stored...")

        # Building labels from regions
        segmentation = regions_to_labels(segmentation=segmentation, regions=args.regions)
        ground_truth = regions_to_labels(segmentation=ground_truth, regions=args.regions)
        logging.info(f"Converted ROI segmentation and ground truth into labels...")

        # Saving sequences and ground truth cropped, and segmentation predicted
        np.save(f"{args.seg_folder}/{patient_id}_sequences", sequences.cpu().numpy())
        WriteImage(GetImageFromArray(ground_truth), f"{args.seg_folder}/{patient_id}_ground_truth.nii.gz")
        WriteImage(GetImageFromArray(segmentation), f"{args.seg_folder}/{patient_id}_segmentation.nii.gz")
        logging.info(f"Sequences, ground truth and segmentation saved successfully...")

    # Generating .csv which contains all metrics
    df_metrics_val = pd.DataFrame([item for sublist in metrics_list for item in sublist])
    df_metrics_val.to_csv((args.save_folder / 'results_by_patient.csv'), index=False)

    print(df_metrics_val)
    df_melt = pd.melt(df_metrics_val,
                      id_vars=["patient_id", "region"],
                      value_vars=METRICS,
                      var_name="metric_name",
                      value_name="value")
    df_summary = df_melt.groupby(["region", "metric_name"]).describe().reset_index()
    df_summary.to_csv(f"{args.save_folder}/summary_metrics.csv", index=False)
    logging.info(f"\nMetrics summary:\n\n{df_summary}")

    # Generating boxplot figures for each metric
    generate_boxplot_metrics(metrics_df=df_metrics_val, path=f"{args.save_folder}/metrics/")
    logging.info(f"Boxplot figures stored in the path {args.save_folder}/metrics/")


def init_log(log_name: str):
    """
    This function initialize a log file.

    Params:
    *******
        - log_name: name of the log

    """
    logging.basicConfig(
        level=logging.INFO,
        format='[%(asctime)s] - [%(levelname)s] - [%(filename)s:%(lineno)s] --- %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        filename=log_name,
        filemode='a',
        force=True
    )

    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    logging.getLogger().addHandler(console)


class AverageMeter(object):
    """Computes and stores the average and current value."""

    def __init__(self, name, fmt=':f'):
        self.name = name
        self.fmt = fmt
        self.reset()
        self.val = 0
        self.avg = 0
        self.sum = 0
        self.count = 0

    def reset(self):
        self.val = 0
        self.avg = 0
        self.sum = 0
        self.count = 0

    def update(self, val, n=1):
        self.val = val
        self.sum += val * n
        self.count += n
        self.avg = self.sum / self.count

    def __str__(self):
        fmtstr = '{name} {val' + self.fmt + '} ({avg' + self.fmt + '})'
        return fmtstr.format(**self.__dict__)


class ProgressMeter(object):
    def __init__(self, num_batches, meters, prefix=""):
        self.batch_fmtstr = self._get_batch_fmtstr(num_batches)
        self.meters = meters
        self.prefix = prefix

    def display(self, batch):
        entries = [self.prefix + self.batch_fmtstr.format(batch)]
        entries += [str(meter) for meter in self.meters]
        logging.info('\t'.join(entries))

    @staticmethod
    def _get_batch_fmtstr(num_batches):
        num_digits = len(str(num_batches // 1))
        fmt = '{:' + str(num_digits) + 'd}'
        return '[' + fmt + '/' + fmt.format(num_batches) + ']'




# def regions_to_labels(segmentation):
#
#     et = segmentation[0]
#     net = np.logical_and(segmentation[1], np.logical_not(et))
#     ed = np.logical_and(segmentation[2], np.logical_not(segmentation[1]))
#
#     # Create label segmentation image
#     segmentationmap = np.zeros(segmentation[0].shape)
#     segmentationmap[et] = 4
#     segmentationmap[net] = 1
#     segmentationmap[ed] = 2
#     segmentationmap = GetImageFromArray(segmentationmap)
#
#     return segmentationmap


